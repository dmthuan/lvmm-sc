
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <math.h>
#include <time.h>
#include <bitset>
#include <iostream>

using namespace std;

typedef unsigned char u8;

#define MAX_WALSH_ID 512

typedef struct {
	unsigned short state; /* the Walsh code generator state */
	unsigned short index; /* the Walsh code index */
	char           used;  /* 1 when state is valid, 0 otherwise */
} WalshMaster;

static WalshMaster *walsh_table;
static char is_initialized = 0;

int walsh_init( void )
	/* It creates and initializes the walsh_table entries.
	walsh_init() should be called before any walsh- functions.
	0 is returned for successful initialization */
{
	if ( !is_initialized ) {
		int i;

		walsh_table = (WalshMaster*) malloc( sizeof(WalshMaster)*MAX_WALSH_ID );
		if ( walsh_table == (WalshMaster*)NULL ) {
			fprintf(stderr, "walsh_init: ...cannot allocate memory!\n");
			return -1;
		}

		for ( i = 0; i < MAX_WALSH_ID; i++ ) {
			walsh_table[i].state = 0;
			walsh_table[i].index = 0;
			walsh_table[i].used  = 0;
		}
		is_initialized = 1;
	}

	return 0;
}

void walsh_end( void )
	/* It deallocates memory and reset init variable. */
{
	if ( is_initialized ) {
		free( walsh_table );
		is_initialized = 0;
	}
}

int walsh_create( unsigned short index, unsigned short seed )
	/* It create a Walsh code generator of the given index with the
	given seed. The Walsh code generator id is returned */
{
	unsigned id;

	for ( id = 0; walsh_table[id].used && (id < MAX_WALSH_ID); id ++ );
	if ( id == MAX_WALSH_ID ) return -1; /* All Walsh gen.'s have been used up */

	walsh_table[id].state = seed;
	walsh_table[id].index = index;
	walsh_table[id].used  = 1;

	return id;
}

void walsh_free( int id )
	/* walsh_free() resets the use flag. */
{
	walsh_table[id].used = 0;
}

char walsh( int id )
	/* walsh() gives the next Walsh sequence of the Walsh code generator.
	The used algorithm is the direct implementation of one given
	at pp542 of "Introduction to Spread Spectrum Communicatrions" by
	Peterson et. al. */
{
	unsigned short dump; /* dumped current state */
	char seq; /* the Wlash sequence */

	dump = walsh_table[id].index & walsh_table[id].state;
	walsh_table[id].state++;

	seq = 0;
	while( dump ) {
		seq ^= dump & 1;
		dump >>= 1;
	}

	return seq;
}

void walsh_set_state( int id, unsigned short seed )
	/* It sets the internal register state to the given state */
{
	walsh_table[id].state = seed;
}

unsigned short walsh_get_state( int id )
	/* It returns the internal register state of the given generator */
{
	return walsh_table[id].state;
}

void walsh_set_index( int id, unsigned short index )
	/* It sets the internal Walsh index as the given index */
{
	walsh_table[id].index = index;
}

unsigned short walsh_get_index( int id )
	/* It returns the internal Walsh code index of the given generator. */
{
	return walsh_table[id].index;
}

////////////////////////////////////////////////////////
// For S-box

/* the s-boxes */
u8 S0[256] = { 0x3e,0x72,0x5b,0x47,0xca,0xe0,0x00,0x33,0x04,0xd1,0x54,0x98,0x09,0xb9,0x6d,0xcb, 0x7b,0x1b,0xf9,0x32,0xaf,0x9d,0x6a,0xa5,0xb8,0x2d,0xfc,0x1d,0x08,0x53,0x03,0x90, 0x4d,0x4e,0x84,0x99,0xe4,0xce,0xd9,0x91,0xdd,0xb6,0x85,0x48,0x8b,0x29,0x6e,0xac, 0xcd,0xc1,0xf8,0x1e,0x73,0x43,0x69,0xc6,0xb5,0xbd,0xfd,0x39,0x63,0x20,0xd4,0x38, 0x76,0x7d,0xb2,0xa7,0xcf,0xed,0x57,0xc5,0xf3,0x2c,0xbb,0x14,0x21,0x06,0x55,0x9b, 0xe3,0xef,0x5e,0x31,0x4f,0x7f,0x5a,0xa4,0x0d,0x82,0x51,0x49,0x5f,0xba,0x58,0x1c, 0x4a,0x16,0xd5,0x17,0xa8,0x92,0x24,0x1f,0x8c,0xff,0xd8,0xae,0x2e,0x01,0xd3,0xad, 0x3b,0x4b,0xda,0x46,0xeb,0xc9,0xde,0x9a,0x8f,0x87,0xd7,0x3a,0x80,0x6f,0x2f,0xc8, 0xb1,0xb4,0x37,0xf7,0x0a,0x22,0x13,0x28,0x7c,0xcc,0x3c,0x89,0xc7,0xc3,0x96,0x56, 0x07,0xbf,0x7e,0xf0,0x0b,0x2b,0x97,0x52,0x35,0x41,0x79,0x61,0xa6,0x4c,0x10,0xfe, 0xbc,0x26,0x95,0x88,0x8a,0xb0,0xa3,0xfb,0xc0,0x18,0x94,0xf2,0xe1,0xe5,0xe9,0x5d, 0xd0,0xdc,0x11,0x66,0x64,0x5c,0xec,0x59,0x42,0x75,0x12,0xf5,0x74,0x9c,0xaa,0x23, 0x0e,0x86,0xab,0xbe,0x2a,0x02,0xe7,0x67,0xe6,0x44,0xa2,0x6c,0xc2,0x93,0x9f,0xf1, 0xf6,0xfa,0x36,0xd2,0x50,0x68,0x9e,0x62,0x71,0x15,0x3d,0xd6,0x40,0xc4,0xe2,0x0f, 0x8e,0x83,0x77,0x6b,0x25,0x05,0x3f,0x0c,0x30,0xea,0x70,0xb7,0xa1,0xe8,0xa9,0x65, 0x8d,0x27,0x1a,0xdb,0x81,0xb3,0xa0,0xf4,0x45,0x7a,0x19,0xdf,0xee,0x78,0x34,0x60};
u8 S1[256] = { 0x55,0xc2,0x63,0x71,0x3b,0xc8,0x47,0x86,0x9f,0x3c,0xda,0x5b,0x29,0xaa,0xfd,0x77, 0x8c,0xc5,0x94,0x0c,0xa6,0x1a,0x13,0x00,0xe3,0xa8,0x16,0x72,0x40,0xf9,0xf8,0x42, 0x44,0x26,0x68,0x96,0x81,0xd9,0x45,0x3e,0x10,0x76,0xc6,0xa7,0x8b,0x39,0x43,0xe1, 0x3a,0xb5,0x56,0x2a,0xc0,0x6d,0xb3,0x05,0x22,0x66,0xbf,0xdc,0x0b,0xfa,0x62,0x48, 0xdd,0x20,0x11,0x06,0x36,0xc9,0xc1,0xcf,0xf6,0x27,0x52,0xbb,0x69,0xf5,0xd4,0x87, 0x7f,0x84,0x4c,0xd2,0x9c,0x57,0xa4,0xbc,0x4f,0x9a,0xdf,0xfe,0xd6,0x8d,0x7a,0xeb, 0x2b,0x53,0xd8,0x5c,0xa1,0x14,0x17,0xfb,0x23,0xd5,0x7d,0x30,0x67,0x73,0x08,0x09, 0xee,0xb7,0x70,0x3f,0x61,0xb2,0x19,0x8e,0x4e,0xe5,0x4b,0x93,0x8f,0x5d,0xdb,0xa9, 0xad,0xf1,0xae,0x2e,0xcb,0x0d,0xfc,0xf4,0x2d,0x46,0x6e,0x1d,0x97,0xe8,0xd1,0xe9, 0x4d,0x37,0xa5,0x75,0x5e,0x83,0x9e,0xab,0x82,0x9d,0xb9,0x1c,0xe0,0xcd,0x49,0x89, 0x01,0xb6,0xbd,0x58,0x24,0xa2,0x5f,0x38,0x78,0x99,0x15,0x90,0x50,0xb8,0x95,0xe4, 0xd0,0x91,0xc7,0xce,0xed,0x0f,0xb4,0x6f,0xa0,0xcc,0xf0,0x02,0x4a,0x79,0xc3,0xde, 0xa3,0xef,0xea,0x51,0xe6,0x6b,0x18,0xec,0x1b,0x2c,0x80,0xf7,0x74,0xe7,0xff,0x21, 0x5a,0x6a,0x54,0x1e,0x41,0x31,0x92,0x35,0xc4,0x33,0x07,0x0a,0xba,0x7e,0x0e,0x34, 0x88,0xb1,0x98,0x7c,0xf3,0x3d,0x60,0x6c,0x7b,0xca,0xd3,0x1f,0x32,0x65,0x04,0x28, 0x64,0xbe,0x85,0x9b,0x2f,0x59,0x8a,0xd7,0xb0,0x25,0xac,0xaf,0x12,0x03,0xe2,0xf2};
u8 AESSbox[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

void CheckBalance()
{
	bitset<256> truth0, truth1, truth2, truth3, truth4, truth5, truth6, truth7;

	for(int i = 0; i < 256; ++i)
	{
		bitset<8> out = S1[i];

		truth0[i] = out[0];
		truth1[i] = out[1];
		truth2[i] = out[2];
		truth3[i] = out[3];
		truth4[i] = out[4];
		truth5[i] = out[5];
		truth6[i] = out[6];
		truth7[i] = out[7];
	}

	int result0 = 0, result1 = 0, result2 = 0, result3 = 0, result4 = 0, result5 = 0, result6 = 0, result7 = 0;

	for(int i = 0; i < 256; ++i)
	{
		if(truth0[i] == 1)
			result0 += 1;
		if(truth1[i] == 1)
			result1 += 1;
		if(truth2[i] == 1)
			result2 += 1;
		if(truth3[i] == 1)
			result3 += 1;
		if(truth4[i] == 1)
			result4 += 1;
		if(truth5[i] == 1)
			result5 += 1;
		if(truth6[i] == 1)
			result6 += 1;
		if(truth7[i] == 1)
			result7 += 1;
	}
	
	cout << "\n" << result0;
	cout << "\n" << result1;
	cout << "\n" << result2;
	cout << "\n" << result3;
	cout << "\n" << result4;
	cout << "\n" << result5;
	cout << "\n" << result6;
	cout << "\n" << result7;
}

int NonlinearitySBox()
{
	int result = 118; // Max Nonlinearity of Boolean func over GF(2)^8

	static const int N = 256;

	// Step 1: compute truth table of component functions
	bitset<256> truth0, truth1, truth2, truth3, truth4, truth5, truth6, truth7;

	for(int i = 0; i < 256; ++i)
	{
		bitset<8> out = AESSbox[i];

		truth0[i] = out[0];
		truth1[i] = out[1];
		truth2[i] = out[2];
		truth3[i] = out[3];
		truth4[i] = out[4];
		truth5[i] = out[5];
		truth6[i] = out[6];
		truth7[i] = out[7];
	}

	for(int i = 1; i < 256; ++i)
	{
		// Step 2: for every Linear Combination
		bitset<256> linearCombination;

		bitset<8> c = i;

		for(int j = 0 ; j < 256; ++j)
		{
			linearCombination[j] = (c[0] & truth0[j]) ^ (c[1] & truth1[j]) ^ (c[2] & truth2[j]) ^ (c[3] & truth3[j])
				^ (c[4] & truth4[j]) ^ (c[5] & truth5[j]) ^ (c[6] & truth6[j]) ^ (c[7] & truth7[j]);
		}

		cout << " " << i;

		// Step 3: compute Nonlinearity of every Linear Combination
		int nonlinearity1 = 256;

		walsh_init();

		for (int i = 0; i < N; ++i)
		{
			int id = walsh_create(i, 0);
			bitset<N> bits;
			for (int j = N-1; j >= 0; --j)
				bits.set(j, walsh(id) ? true : false);
			bitset<N> temp = linearCombination ^ bits;

			int hw = 0;
			// compute Hamming weight
			for(int j = 0; j < N; ++j)
			{
				if(temp.at(j) == 1)
					hw++;
			}
			if(hw < nonlinearity1)
				nonlinearity1 = hw;

			walsh_free(id);
		}

		// continuous forward to affine functions --> comparing for 2^(N+1) Boolean function

		int nonlinearity2 = 256;

		for (int i = 0; i < N; ++i)
		{
			int id = walsh_create(i, 0);
			bitset<N> bits;
			for (int j = N-1; j >= 0; --j)
				bits.set(j, walsh(id) ? false : true);
			bitset<N> temp = linearCombination ^ bits;

			int hw = 0;
			// compute Hamming weight
			for(int j = 0; j < N; ++j)
			{
				if(temp.at(j) == 1)
					hw++;
			}
			if(hw < nonlinearity2)
				nonlinearity2 = hw;

			walsh_free(id);
		}

		int nonlinearity = nonlinearity2;
		if(nonlinearity1 < nonlinearity2)
			nonlinearity = nonlinearity1;

		// Step 4: compute result
		if(nonlinearity < result)
			result = nonlinearity;
	}

	return result;
}

int onBit(int a, int i)
{
	int b = 1 << i;
	return a | b;
}

int offBit(int a, int i)
{
	int b = !(1 << i);
	return a & b;
}

int countBit1(bitset<256> a)
{
	int sum = 0;
	for(int i = 0; i < 256; ++i)
	{
		if(a[i] == 1)
			sum +=1;
	}
	return sum;
}

// check SAC
void SAC(int bit)
{
	bitset<256> bit0, bit1, bit2, bit3, bit4, bit5, bit6, bit7;
	bitset<256> bit_0, bit_1, bit_2, bit_3, bit_4, bit_5, bit_6, bit_7;

	for(int i = 0; i < 256; ++i)
	{
		//int j = offBit(i, bit);
		bitset<8> out = S0[i];

		bit0[i] = out[0];
		bit1[i] = out[1];
		bit2[i] = out[2];
		bit3[i] = out[3];
		bit4[i] = out[4];
		bit5[i] = out[5];
		bit6[i] = out[6];
		bit7[i] = out[7];
	}

	for(int i = 0; i < 256; ++i)
	{
		int j = i ^ (1 << bit);
		bitset<8> out = S0[j];

		bit_0[i] = out[0];
		bit_1[i] = out[1];
		bit_2[i] = out[2];
		bit_3[i] = out[3];
		bit_4[i] = out[4];
		bit_5[i] = out[5];
		bit_6[i] = out[6];
		bit_7[i] = out[7];
	}

	bitset<256> bits0, bits1, bits2, bits3, bits4, bits5, bits6, bits7;

	bits0 = bit0 ^ bit_0;
	bits1 = bit1 ^ bit_1;
	bits2 = bit2 ^ bit_2;
	bits3 = bit3 ^ bit_3;
	bits4 = bit4 ^ bit_4;
	bits5 = bit5 ^ bit_5;
	bits6 = bit6 ^ bit_6;
	bits7 = bit7 ^ bit_7;

	cout << " " << countBit1(bits0);
	cout << " " << countBit1(bits1);
	cout << " " << countBit1(bits2);
	cout << " " << countBit1(bits3);
	cout << " " << countBit1(bits4);
	cout << " " << countBit1(bits5);
	cout << " " << countBit1(bits6);
	cout << " " << countBit1(bits7);
}

int main()
{
	/*static const int N = 256;

	srand ( time(NULL) );

	bitset<N> func;

	for(int i = 0; i < N; ++i)
	{
		func.at(i) = rand()%2;
	}

	int nonlinearity1 = 256;

	walsh_init();

	for (int i = 0; i < N; ++i)
	{
		int id = walsh_create(i, 0);
		bitset<N> bits;
		for (int j = N-1; j >= 0; --j)
			bits.set(j, walsh(id) ? true : false);
		//cout << i << ": " << bits << endl;
		bitset<N> temp = func ^ bits;

		int hw = 0;
		// compute Hamming weight
		for(int j = 0; j < N; ++j)
		{
			if(temp.at(j) == 1)
				hw++;
		}
		if(hw < nonlinearity1)
			nonlinearity1 = hw;

		walsh_free(id);
	}

	// continuous forward to affine functions --> comparing for 2^(N+1) Boolean function

	int nonlinearity2 = 256;

	for (int i = 0; i < N; ++i)
	{
		int id = walsh_create(i, 0);
		bitset<N> bits;
		for (int j = N-1; j >= 0; --j)
			bits.set(j, walsh(id) ? false : true);
		//cout << i << ": " << bits << endl;
		bitset<N> temp = func ^ bits;

		int hw = 0;
		// compute Hamming weight
		for(int j = 0; j < N; ++j)
		{
			if(temp.at(j) == 1)
				hw++;
		}
		if(hw < nonlinearity2)
			nonlinearity2 = hw;

		walsh_free(id);
	}

	int nonlinearity = nonlinearity2;
	if(nonlinearity1 < nonlinearity2)
		nonlinearity = nonlinearity1;

	cout << "\nNonlinearity = " << nonlinearity;
	cout << "\nNonlinearity1 = " << nonlinearity1;
	cout << "\nNonlinearity2 = " << nonlinearity2;
	cout << "\n" << func;

	walsh_end();

	cin.get();*/

	//cout << "\nNonlinearity of S-box: " << NonlinearitySBox() << endl;

	SAC(7);

	//CheckBalance();

	return 0;
}